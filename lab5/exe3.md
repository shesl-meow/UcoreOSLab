> 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的?

- `fork`创建了一个新的进程，状态为`PROC_UNINIT`，创建成功则唤醒新的进程，状态变为`PROC_RUNNABLE`。
- `exec`收回当前进程的内存空间，调用`load_icode`来加载并解析一个处于内存中
  的`ELF`执行文件格式的应用程序,建立相应的用户内存空间来放置应用程序的代码段、数据段
  等。
- `wait`
  1. 找到处于`PROC_ZOMBIE`状态的子进程。
  
  2. 如果此子进程的执行状态不为`PROC_ZOMBIE`，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为`PROC_SLEEPING`，设置为等待子进程退出，调用`schedule()`函数选择新的进程执行，自己睡眠等待，如果被唤醒，则跳回步骤1处执行，如果自己该退出了则调用`do_exit()`退出。
  
  3. 如果此子进程的执行状态为`PROC_ZOMBIE`，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作。

- `exit`

  设置当前进程的执行状态为`PROC_ZOMBIE`，当前进程的退出码为`error_code`。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作。

  如果当前进程的父进程处于等待子进程状态，则唤醒父进程，让父进程帮助自己完成最后的资源回收；

  如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程`initproc`，且各个子进程指针需要插入到`initproc`的子进程链表中。如果某个子进程的执行状态是`PROC_ZOMBIE`，则需要唤醒`initproc`来完成对此子进程的最后回收工作。

  执行`schedule()`函数，选择新的进程执行。

> 请给出ucore中一个用户态进程的执行状态生命周期图(包执行状态,执行状态之间的变
> 换关系,以及产生变换的事件或函数调用)。(字符方式画即可)

do_fork()(alloc_proc()-->UNINIT-->wakeup_proc()-->RUNNABLE)-->RUNNABLE

​                                                                                                                                                    |proc_run()

​                                                                                               子进程do_exit()  --> RUNNING---->do_exit()---->ZOMBIE

​                                                                                                                                                    |do_wait()/do_sleep()/free_page()

​                                                                                                                                          SLEEPING